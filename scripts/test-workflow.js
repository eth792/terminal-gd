#!/usr/bin/env node
/**
 * ç«¯åˆ°ç«¯å·¥ä½œæµæµ‹è¯•è„šæœ¬
 *
 * éªŒè¯æ‰€æœ‰è‡ªåŠ¨åŒ–è„šæœ¬çš„åŠŸèƒ½å®Œæ•´æ€§
 */

import { existsSync, readFileSync } from 'fs';
import { resolve } from 'path';

console.log('ğŸ§ª ç«¯åˆ°ç«¯å·¥ä½œæµæµ‹è¯• - å¼€å§‹\n');

const tests = [];
let passedTests = 0;
let failedTests = 0;

// æµ‹è¯•è¾…åŠ©å‡½æ•°
function test(name, fn) {
  tests.push({ name, fn });
}

async function runTests() {
  for (const { name, fn } of tests) {
    try {
      await fn();
      console.log(`âœ… ${name}`);
      passedTests++;
    } catch (error) {
      console.error(`âŒ ${name}`);
      console.error(`   Error: ${error.message}`);
      failedTests++;
    }
  }

  console.log('\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”');
  console.log(`ğŸ“Š æµ‹è¯•ç»“æœ: ${passedTests}/${tests.length} é€šè¿‡`);

  if (failedTests > 0) {
    console.log(`   âš ï¸  ${failedTests} ä¸ªæµ‹è¯•å¤±è´¥`);
  }

  console.log('â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n');

  return failedTests === 0;
}

// ============================================================
// æµ‹è¯•ç”¨ä¾‹
// ============================================================

test('1. æ ¸å¿ƒè„šæœ¬æ–‡ä»¶å­˜åœ¨', () => {
  const files = [
    'scripts/update-docs.js',
    'scripts/release.js'
  ];

  for (const file of files) {
    if (!existsSync(file)) {
      throw new Error(`File not found: ${file}`);
    }
  }
});

test('2. package.json åŒ…å«å¿…éœ€çš„ scripts', () => {
  const packageJson = JSON.parse(readFileSync('package.json', 'utf-8'));

  const requiredScripts = ['update-docs', 'release'];

  for (const script of requiredScripts) {
    if (!packageJson.scripts[script]) {
      throw new Error(`Missing script in package.json: ${script}`);
    }
  }
});

test('3. update-docs.js å¯¼å‡ºæ‰€æœ‰å¿…éœ€å‡½æ•°', async () => {
  const updateDocs = await import('./update-docs.js');

  const requiredExports = [
    'safeExtractKPI',
    'atomicUpdate',
    'updateImplementationRecord',
    'updateProjectStatus',
    'updateClaudeMd',
    'updateDocs'
  ];

  for (const exportName of requiredExports) {
    if (typeof updateDocs[exportName] !== 'function') {
      throw new Error(`Missing export: ${exportName}`);
    }
  }
});

test('4. release.js å¯¼å‡ºæ‰€æœ‰å¿…éœ€å‡½æ•°', async () => {
  const release = await import('./release.js');

  const requiredExports = [
    'checkTestRuns',
    'promptUserInput',
    'release'
  ];

  for (const exportName of requiredExports) {
    if (typeof release[exportName] !== 'function') {
      throw new Error(`Missing export: ${exportName}`);
    }
  }
});

test('5. æ ¸å¿ƒæ–‡æ¡£å­˜åœ¨ä¸”æ ¼å¼æ­£ç¡®', () => {
  const docs = [
    'CLAUDE.md',
    'docs/PROJECT_STATUS.md',
    'docs/implementation_record.md'
  ];

  for (const doc of docs) {
    if (!existsSync(doc)) {
      throw new Error(`Document not found: ${doc}`);
    }

    const content = readFileSync(doc, 'utf-8');

    // æ£€æŸ¥æ–‡æ¡£ä¸ä¸ºç©º
    if (content.trim().length === 0) {
      throw new Error(`Document is empty: ${doc}`);
    }
  }
});

test('6. æ–‡æ¡£åŒ…å«è‡ªåŠ¨ç”Ÿæˆæ ‡è®°', () => {
  const files = [
    { path: 'CLAUDE.md', marker: 'AUTOGENERATED SECTION' },
    { path: 'docs/PROJECT_STATUS.md', marker: 'AUTOGENERATED SECTION' },
    { path: 'docs/implementation_record.md', marker: 'AUTOGENERATED SECTION' }
  ];

  for (const { path, marker } of files) {
    const content = readFileSync(path, 'utf-8');

    if (!content.includes(marker)) {
      throw new Error(`Missing autogenerated marker in: ${path}`);
    }
  }
});

test('7. CLAUDE.md åŒ…å«å¿«é€Ÿæ¢å¤ç« èŠ‚', () => {
  const content = readFileSync('CLAUDE.md', 'utf-8');

  const requiredSections = [
    'å¿«é€ŸçŠ¶æ€æ¢å¤',
    'æ ¸å¿ƒ KPI',
    'æœ€è¿‘å®Œæˆçš„å·¥ä½œ',
    'ä¸‹ä¸€æ­¥è®¡åˆ’'
  ];

  for (const section of requiredSections) {
    if (!content.includes(section)) {
      throw new Error(`Missing section in CLAUDE.md: ${section}`);
    }
  }
});

test('8. PROJECT_STATUS.md ç»“æ„å®Œæ•´', () => {
  const content = readFileSync('docs/PROJECT_STATUS.md', 'utf-8');

  const requiredSections = [
    'å½“å‰çŠ¶æ€å¿«ç…§',
    'æ ¸å¿ƒæŒ‡æ ‡',
    'ç‰ˆæœ¬å†å²',
    'é¡¹ç›®è·¯çº¿å›¾'
  ];

  for (const section of requiredSections) {
    if (!content.includes(section)) {
      throw new Error(`Missing section in PROJECT_STATUS.md: ${section}`);
    }
  }
});

test('9. implementation_record.md åŒ…å«å¯¼èˆªå’Œ FAQ', () => {
  const content = readFileSync('docs/implementation_record.md', 'utf-8');

  const requiredSections = [
    'å¿«é€Ÿå¯¼èˆª',
    'FAQ',
    'ç‰ˆæœ¬å†å²'
  ];

  for (const section of requiredSections) {
    if (!content.includes(section)) {
      throw new Error(`Missing section in implementation_record.md: ${section}`);
    }
  }

  // éªŒè¯ FAQ ä½¿ç”¨äº†æŠ˜å æ ‡ç­¾
  if (!content.includes('<details>')) {
    throw new Error('FAQ section does not use collapsible <details> tags');
  }
});

test('10. checkTestRuns å‡½æ•°å¯ä»¥æ­£å¸¸è°ƒç”¨', async () => {
  const { checkTestRuns } = await import('./release.js');

  // è°ƒç”¨å‡½æ•°ï¼ˆä¸å…³å¿ƒè¿”å›å€¼ï¼ŒåªéªŒè¯ä¸æŠ›å‡ºå¼‚å¸¸ï¼‰
  const result = await checkTestRuns();

  // éªŒè¯è¿”å›å€¼ç»“æ„
  if (typeof result !== 'object') {
    throw new Error('checkTestRuns should return an object');
  }

  if (!('hasRuns' in result)) {
    throw new Error('checkTestRuns result missing hasRuns property');
  }
});

// ============================================================
// è¿è¡Œæµ‹è¯•
// ============================================================

async function main() {
  const success = await runTests();

  if (success) {
    console.log('âœ… æ‰€æœ‰æµ‹è¯•é€šè¿‡ï¼å·¥ä½œæµéªŒè¯æˆåŠŸã€‚\n');
    process.exit(0);
  } else {
    console.log('âŒ éƒ¨åˆ†æµ‹è¯•å¤±è´¥ã€‚è¯·æ£€æŸ¥ä¸Šè¿°é”™è¯¯ä¿¡æ¯ã€‚\n');
    process.exit(1);
  }
}

main();
