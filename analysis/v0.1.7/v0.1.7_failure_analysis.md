# v0.1.7 实施失败分析报告

**创建日期**: 2025-11-14
**版本定位**: P0 级修复尝试 - 提取逻辑根本缺陷（**失败，已回滚**）
**测试运行包**: `runs/run_v0.1.7_full_$(date +%Y%m%d_%H%M%S)/` (目录名未展开)

---

## 🚨 执行总结

**状态**: ❌ **完全失败 - 灾难性回归**

**实施内容**:
- 清理 label_alias.json 配置污染
- 修复标签匹配子串误匹配（添加分隔符检查）
- 实施跨字段标签排除机制
- 移除续行拼接的 endsWithEntity 误判

**测试结果** (完整测试，222 样本):

| 指标 | v0.1.6 | v0.1.7 | 变化 | 变化率 |
|------|--------|--------|------|--------|
| **自动通过率** | **32.0%** | **0.0%** | **-32.0%** | **-100.0%** |
| Exact | 71 | 0 | -71 | -100.0% |
| Review | 25 | 1 | -24 | -96.0% |
| Fail | 126 | 221 | +95 | +75.4% |

**关键失败指标**:
- FIELD_SIM_LOW_SUPPLIER: 21 → **121** (+100, **+476%**)
- EXTRACT_EMPTY_SUPPLIER: 0 → **27** (新增)
- 测试耗时: 53.8 分钟

**回滚状态**: ✅ 已完全回滚至 v0.1.6 代码

---

## 💥 灾难性失败现象

### 现象 1: 过度拼接（Over-Concatenation）

**典型案例**: `wuhanxinghuodianxiandianlan4100961501.txt`

**v0.1.6 提取结果**（正确）:
```
q_supplier: "武汉星火电线电缆有限公司"
q_project:  "新希望华中区域总部P13地块新住配工程"
```

**v0.1.7 提取结果**（错误）:
```
q_supplier: "武汉星火电线电缆有限公司武汉锦府置有限公司新希望华中区"
q_project:  "新希望华中区域总部P13地块新住配工程"
```

**分析**:
- 供应商名称后直接拼接了下一行的另一家公司名称
- 移除 `endsWithEntity` 检查导致无法阻止这种拼接
- 原 OCR 布局可能是：
  ```
  供应商：武汉星火电线电缆有限公司
        武汉锦府置有限公司新希望华中区...（这是工程名称的一部分）
  ```

### 现象 2: 提取失败（Empty Extraction）

**新增 27 个 EXTRACT_EMPTY_SUPPLIER 案例**

**典型案例**: `beijingsifangjibaogongchengjishuyouxiangongsi4100862689.txt`

**v0.1.6 提取结果**（虽然错误，但至少有值）:
```
q_supplier: ""（可能有值）
q_project:  "武汉绿地滨江置业有限公司绿地国际金融城A02地块..."
```

**v0.1.7 提取结果**（完全失败）:
```
q_supplier: ""
q_project:  "武汉绿地滨江置业有限公司绿地国际金融城A02地块..."
```

**分析**:
- 分隔符检查过于严格，导致合法的标签位置被跳过
- 可能的原因：OCR 错误导致标签后没有标准分隔符（如"供应商武汉...\"）

### 现象 3: 字段相似度崩溃

**FIELD_SIM_LOW_SUPPLIER 案例激增**: 21 → 121 (+476%)

**原因**:
1. 过度拼接导致 q_supplier 包含两个公司名称，与 DB 的单一公司名无法匹配
2. 提取失败导致 q_supplier 为空，f1_score = 0.0

---

## 🔍 根本原因分析

### 原因 1: endsWithEntity 检查的作用被误解

**原设计意图**: 避免拼接其他字段的值（如下一行的工程名称）

**v0.1.7 修改**: 移除此检查，认为 `hasOtherLabel` 已经足够

**实际问题**:
- `hasOtherLabel` 只检查标签（如"工程名称："），但不检查**未带标签的工程名称内容**
- OCR 布局复杂时，工程名称的内容可能跨多行，且不带标签
- 移除 `endsWithEntity` 后，供应商名称会盲目拼接下一行的工程名称内容

**示例布局**:
```
供应商：武汉星火电线电缆有限公司
      武汉锦府置有限公司新希望华中区域总部P13地块  ← 这是工程名称的一部分，但没有标签
工程名称：（标签在更下方）
```

### 原因 2: 分隔符检查过于严格

**v0.1.7 添加的检查**:
```typescript
const afterLabel = line.substring(labelIndex + label.length);
if (afterLabel && !/^[:：=\s/]/.test(afterLabel)) {
  continue; // 标签后不是分隔符，跳过
}
```

**问题**:
- OCR 错误可能导致分隔符缺失（如"供应商武汉..."）
- 此检查会跳过这些合法的标签位置
- 导致 27 个案例无法提取供应商

**应该的设计**: 宽容 OCR 错误，允许标签后直接跟值（但需要其他方式防止子串误匹配）

### 原因 3: 跨字段排除机制不完整

**v0.1.7 实现**:
```typescript
const hasOtherLabel = allFieldLabels
  .filter(l => !labels.includes(l))
  .some(l => prevLine.includes(l));
```

**问题**:
- 只检查**带标签**的行
- 无法检测**不带标签的字段内容**（如工程名称的续行）
- 需要结合内容特征（如 endsWithEntity）来判断

---

## 📊 失败数据分析

### 测试运行包目录问题

**目录名**: `runs/run_v0.1.7_full_$(date +%Y%m%d_%H%M%S)/`

**问题**: Shell 变量未展开，导致目录名为字面字符串

**原因**: 使用单引号包裹命令，导致变量替换失败

**修复**: 使用双引号，并改为分钟级精度（`%Y%m%d_%H%M`）

### 失败案例分布

| 失败原因 | 案例数 | 占比 | v0.1.6 基线 | 变化 |
|---------|--------|------|-------------|------|
| FIELD_SIM_LOW_SUPPLIER | 121 | 54.5% | 21 | +476% |
| FIELD_SIM_LOW_PROJECT | 48 | 21.6% | 48 | 0% |
| EXTRACT_EMPTY_SUPPLIER | 27 | 12.2% | 0 | +∞ |
| EXTRACT_EMPTY_PROJECT | 4 | 1.8% | 4 | 0% |
| EXTRACT_BOTH_EMPTY | 15 | 6.8% | 15 | 0% |
| DELTA_TOO_SMALL | 0 | 0.0% | 27 | -100% |
| 其他 | 6 | 2.7% | 11 | -45% |

**关键发现**:
- FIELD_SIM_LOW_SUPPLIER 激增 100 个案例（从 21 到 121）
- EXTRACT_EMPTY_SUPPLIER 新增 27 个案例
- DELTA_TOO_SMALL 全部消失（因为没有案例能匹配到 autoPass 门槛）

---

## 🎓 经验教训

### 教训 1: 不要一次修改多个关键逻辑

**v0.1.7 同时修改了 4 个关键点**:
1. 配置清理（label_alias.json）
2. 分隔符检查（substring matching）
3. 跨字段排除（cross-field exclusion）
4. 移除 endsWithEntity 检查

**问题**: 无法定位哪个修改导致了失败

**正确做法**: 逐个修改并测试（A/B testing）

### 教训 2: 理解现有逻辑的真实意图

**endsWithEntity 的真实作用**:
- 不仅仅是"避免拼接其他字段的值"
- 更是一种**内容特征检测**（检测是否是公司名称的结尾）
- 与 `hasOtherLabel` 的标签检测是**互补**关系，不是替代

**错误假设**: 认为标签检查能替代内容特征检测

### 教训 3: 配置清理需要验证实际 OCR 文本

**label_alias.json 清理过于激进**:
- 移除了"供应单位名称"、"采购订单供应商"等标签
- 可能在某些 OCR 文本中，这些标签确实存在且有效
- 应该先 grep 验证实际出现频率，再决定是否移除

### 教训 4: 分隔符检查不能过于严格

**OCR 的现实**:
- 分隔符经常缺失或变形
- 必须容忍"供应商武汉..."这种没有冒号的情况
- 严格的正则检查会导致大量漏提取

### 教训 5: 增量测试的重要性

**应该的流程**:
1. 仅修改 label_alias.json → 测试 10-20 个样本
2. 如果有效，添加分隔符检查 → 再测试 10-20 个样本
3. 如果有效，添加跨字段排除 → 再测试 10-20 个样本
4. 如果有效，考虑移除 endsWithEntity → 再测试 10-20 个样本
5. 最后才运行完整测试

**v0.1.7 的错误**: 直接运行完整测试，浪费 53.8 分钟，且无法定位问题

---

## 🔄 回滚记录

**回滚时间**: 2025-11-14

**回滚命令**:
```bash
git restore configs/v0.labs/10dae06c/label_alias.json \
            packages/ocr-match-core/src/extract/extractor.ts
```

**回滚文件**:
- `configs/v0.labs/10dae06c/label_alias.json` - 恢复到 v0.1.6 配置（包含原有标签）
- `packages/ocr-match-core/src/extract/extractor.ts` - 恢复到 v0.1.6 提取逻辑（保留 endsWithEntity 检查）

**验证**: 回滚后代码与 commit `14a5eb79` (feat(ocr-core): v0.1.6 规划提交) 之前的状态一致

---

## 🚀 下一步行动建议

### 立即行动（修复 v0.1.7）

1. **采用增量测试策略**
   - 创建 10-20 个代表性样本的小测试集
   - 每次只修改一个点，立即测试验证
   - 只有验证通过才继续下一个修改

2. **重新评估 endsWithEntity 的作用**
   - 不是简单的"移除"，而是**改进**
   - 可能需要更复杂的内容特征检测（如"是否包含公司名称关键词"）
   - 或者结合 `hasOtherLabel` 和内容特征，双重保险

3. **重新设计跨字段排除**
   - 不仅检查标签，还要检查内容特征
   - 可能需要引入"字段边界检测"机制（如检测空行、缩进变化等）

4. **分隔符检查放宽**
   - 允许标签后直接跟值（无分隔符）
   - 用其他方式防止子串误匹配（如检查标签前后是否有空格/换行）

### 中期行动（v0.1.8+）

1. **引入表格结构识别**
   - 当前行级扫描无法处理复杂布局
   - 可能需要识别表格结构，提取表格单元格内容

2. **引入字段边界检测**
   - 检测空行、缩进变化、分隔线等布局特征
   - 用于判断字段的开始和结束

3. **引入内容特征库**
   - 建立"供应商名称特征"库（如"有限公司"、"股份"等）
   - 建立"工程名称特征"库（如"工程"、"项目"、"地块"等）
   - 用于内容验证和边界检测

---

## 📚 相关文档

- **规划文档**: `analysis/v0.1.7/v0.1.7_plan.md`
- **问题诊断**: `analysis/v0.1.6/extraction_issues.md`
- **项目状态**: `docs/PROJECT_STATUS.md`
- **实施记录**: `docs/implementation_record.md`

---

## 🏁 总结

v0.1.7 是一次**完全失败**的尝试，自动通过率从 32.0% 崩溃至 0.0%。

**核心问题**: 对现有逻辑的理解不足，同时修改过多关键点，缺乏增量验证。

**关键教训**:
- ✅ endsWithEntity 不是"Bug"，而是必要的内容特征检测
- ✅ 跨字段排除需要标签检测 + 内容特征检测的双重机制
- ✅ 分隔符检查不能过于严格，必须容忍 OCR 错误
- ✅ 配置清理需要基于实际 OCR 文本分析，不能凭想象
- ✅ 增量测试是王道，完整测试只用于最终验证

**下一步**: 回归 v0.1.6 基线，采用更保守的增量优化策略，逐个验证每个修改点的有效性。
