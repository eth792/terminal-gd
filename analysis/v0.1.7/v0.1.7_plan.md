# v0.1.7 实施计划 - 提取逻辑根本缺陷修复

**创建日期**: 2025-11-13
**版本定位**: P0 级修复 - 提取逻辑设计缺陷（配置污染 + 跨字段排除 + 标签匹配）

---

## 📊 版本定位

v0.1.7 = **提取逻辑根本缺陷修复** - 解决"只提取供应商和工程名称"的原始需求偏差

**问题来源**: v0.1.6 实测发现 50% 失败案例（21/126 FIELD_SIM_LOW_SUPPLIER）源于提取错误

**核心价值**: 这是比 Rule 3.5 调整更重要的修复（预期 +5-7% vs +0.5%，10倍 ROI）

---

## ✅ 任务列表

### 核心任务（必须完成，否则不发版）

#### 任务 1: 清理 label_alias.json 配置污染
- **问题**: 配置混入了不应该提取的标签
  - ❌ `"供应商联系人"` - 这是联系人字段，不是供应商名称
  - ❌ `"供应商联系方式"` - 这是联系方式字段，不是供应商名称
  - ❌ `"项目定义号"` 等 - 这些是编号字段，不是工程名称
  - ❌ 整个 `order` 字段 - 原始需求没提到要提取订单
- **解决方案**: 只保留真实的提取字段标签 + OCR 错误变体
  ```json
  {
    "supplier": ["供应商", "供应尚", "侯应商"],
    "project": ["工程名称", "T.程名称", "丁程名称", "工理名称", "工程名杆"]
  }
  ```
- **状态**: ✅ 已完成

#### 任务 2: 修复标签匹配子串误匹配
- **问题**: `"供应商"` 会误匹配 `"供应商联系人"`（子串匹配）
- **解决方案**: 添加分隔符检查，标签后必须紧跟冒号/空格/行尾
  ```typescript
  const afterLabel = line.substring(labelIndex + label.length);
  if (afterLabel && !/^[:：=\s/]/.test(afterLabel)) {
    continue; // 不是合法的标签位置
  }
  ```
- **状态**: ✅ 已完成

#### 任务 3: 实施跨字段标签排除机制
- **问题**: 提取 `supplier` 时，会盲目拼接包含 `"工程名称"` 的行
- **解决方案**: 在向上/向下查找时，检查是否包含其他字段的标签
  ```typescript
  const allFieldLabels = [
    ...config.label_alias.supplier,
    ...config.label_alias.project,
  ];

  const hasOtherLabel = allFieldLabels
    .filter(l => !labels.includes(l))  // 排除当前字段
    .some(l => nextLine.includes(l));   // 检查其他字段

  if (!hasOtherLabel) {
    // 可以拼接
  }
  ```
- **状态**: ✅ 已完成

#### 任务 4: 移除续行拼接的 endsWithEntity 误判
- **问题**: 供应商名称本身就以"公司"结尾，导致误判为"不应拼接"
- **解决方案**: 移除 `endsWithEntity` 检查，跨字段排除已经足够
- **状态**: ✅ 已完成

### 附加任务（可延后）

#### 任务 5: 添加 document_field_labels 配置
- **问题**: 文档字段（如"项目管理单位"、"报装编号"等）会干扰提取
- **解决方案**: 在 `domain.json` 中添加文档字段标签黑名单
  ```json
  {
    "document_field_labels": [
      "项目管理单位",
      "报装编号",
      "到货验收单号",
      ...
    ]
  }
  ```
- **状态**: ⏭️ 延后到 v0.1.8（详见"实施调整"章节）

---

## 🛠️ 技术方案

### 修复 1: 配置清理

**原配置问题**：
```json
{
  "supplier": [
    "供应商",           // ✅ 正确
    "供应单位名称",     // ❌ 实际不存在
    "供应商联系人",     // ❌ 这是联系人字段！
    "供应商联系方式",   // ❌ 这是联系方式字段！
    "采购订单供应商"    // ❌ 实际不存在
  ]
}
```

**修复后**（基于实际 OCR 文本分析）：
```json
{
  "supplier": [
    "供应商",    // 193/222 文件存在（87%）
    "供应尚",    // OCR 错误变体
    "侯应商"     // OCR 错误变体
  ],
  "project": [
    "工程名称",  // 194/222 文件存在（87.4%）
    "T.程名称",  // 实际发现的 OCR 错误（"工" → "T."）
    "丁程名称",  // OCR 错误变体
    "工理名称",  // 实际发现的 OCR 错误（normalize.user.json 中有修复）
    "工程名杆"   // OCR 错误变体
  ]
}
```

**数据支撑**：
- 对 222 个 OCR 文本进行 grep 分析
- 只保留真实存在的标签或合理的 OCR 错误变体
- 移除 `order` 字段（原始需求未提及）

### 修复 2: 标签匹配精确化

**代码位置**: `packages/ocr-match-core/src/extract/extractor.ts:98-110`

**修复前**：
```typescript
const labelIndex = line.indexOf(label);
if (labelIndex === -1) continue;

// 直接提取 → 子串误匹配！
let value = line.substring(labelIndex + label.length).trim();
```

**修复后**：
```typescript
const labelIndex = line.indexOf(label);
if (labelIndex === -1) continue;

// 验证标签后是否紧跟分隔符
const afterLabel = line.substring(labelIndex + label.length);
if (afterLabel && !/^[:：=\s/]/.test(afterLabel)) {
  continue; // 标签后不是分隔符，跳过
}

let value = line.substring(labelIndex + label.length).trim();
```

**解决的问题**：
- `"供应商"` 不再误匹配 `"供应商联系人"`
- `"工程名称"` 不再误匹配 `"工程名称报装编号"`

### 修复 3: 跨字段排除机制

**代码位置**:
- `packages/ocr-match-core/src/extract/extractor.ts:32-36` (收集所有标签)
- `packages/ocr-match-core/src/extract/extractor.ts:136-138` (向上查找检查)
- `packages/ocr-match-core/src/extract/extractor.ts:167-169` (续行拼接检查)

**核心逻辑**：
```typescript
// 在 extract() 函数中收集所有字段标签
const allFieldLabels = [
  ...config.label_alias.supplier,
  ...config.label_alias.project,
];

// 传给 extractField()
const supplier = extractField(
  lines, linesRaw,
  config.label_alias.supplier,  // 当前字段的标签
  allFieldLabels,                // 所有字段的标签
  config.domain.noise_words
);
```

**向上/向下查找时检查**：
```typescript
// 修复前（只检查当前字段）
const hasOtherLabel = labels.some(l => prevLine.includes(l));

// 修复后（检查所有其他字段）
const hasOtherLabel = allFieldLabels
  .filter(l => !labels.includes(l))  // 排除当前字段
  .some(l => prevLine.includes(l));   // 检查其他字段
```

**解决的问题**：
- 提取 `supplier` 时，遇到 `"工程名称："` 会停止拼接
- 提取 `project` 时，遇到 `"供应商："` 会停止拼接
- 避免盲目拼接其他字段的内容

### 修复 4: 移除 endsWithEntity 误判

**代码位置**: `packages/ocr-match-core/src/extract/extractor.ts:165-174`

**修复前**：
```typescript
const endsWithEntity = /公司|有限|集团$/.test(nextLine);

if (nextLine && isDeepIndent && !hasOtherLabel && !startsWithNoise && !endsWithEntity) {
  value = value ? value + ' ' + nextLine : nextLine;
}
```

**修复后**：
```typescript
// 移除 endsWithEntity 检查
if (nextLine && isDeepIndent && !hasOtherLabel && !startsWithNoise) {
  value = value ? value + ' ' + nextLine : nextLine;
}
```

**问题根源**：
- 原意：避免拼接其他字段的值（如"武汉XX置业有限公司"）
- 实际：供应商名称本身就以"公司"结尾（如"北京四方继保工程技术有限公司"）
- 结果：正确的供应商名称被误判为"不应拼接"

**修复逻辑**：
- `hasOtherLabel` 已经能检查下一行是否包含其他字段标签
- `endsWithEntity` 是冗余且错误的检查，应移除

---

## 📈 预期效果

### 修复前（v0.1.6）
- 自动通过率：32.0%
- FIELD_SIM_LOW_SUPPLIER 案例：21 个（13.9% 失败原因占比）
- 典型错误：
  - `q_supplier = "A区新建住宅供电配套工程"` ❌（提取到工程名称）
  - `q_supplier = "工程"` ❌（只提取到 anchor 词）
  - `q_supplier = "项目管理单位:..."` ❌（拼接了其他字段）

### 修复后（v0.1.7 预期）
- 自动通过率：**35-37%** (+3-5%)
- FIELD_SIM_LOW_SUPPLIER 案例：**10-15 个**（减少 30-50%）
- 救回案例数：**6-11 个**

### ROI 分析
- 修复成本：2-3 小时（配置清理 + 代码修改 + 测试）
- 收益：+3-5% 自动通过率
- **ROI：6-10倍**（相比 v0.1.6 Rule 3.5 调整的 0.5% 收益）

---

## ⚠️ 风险评估

### 风险 1: 过度严格的排除可能导致漏提取

**风险描述**：
- 跨字段排除逻辑可能过于激进
- 某些合法的内容被错误排除

**缓解措施**：
- 在完整测试中监控 `EXTRACT_EMPTY_*` 警告的增加
- 如果漏提取增加 > 5%，需要调整排除逻辑

**监控指标**：
- EXTRACT_EMPTY_SUPPLIER 警告数量（v0.1.6 基线：待测试）
- EXTRACT_EMPTY_PROJECT 警告数量（v0.1.6 基线：待测试）

### 风险 2: OCR 错误可能影响标签匹配

**风险描述**：
- 当前配置的 OCR 错误变体可能不全
- 某些未预见的 OCR 错误导致标签匹配失败

**缓解措施**：
- 基于 222 个样本的实际分析，覆盖常见 OCR 错误
- 在实测报告中记录未匹配的案例，供后续优化

**监控指标**：
- 新增的 EXTRACT_EMPTY_* 案例中，是否有 OCR 错误导致的标签未匹配

### 风险 3: 布局复杂性超出预期

**风险描述**：
- 部分文档的布局可能非常复杂
- 单纯的向上/向下查找无法正确提取

**缓解措施**：
- v0.1.7 专注于修复已知的设计缺陷
- 复杂布局的优化留待后续版本（如引入表格识别）

**监控指标**：
- 完整测试后，分析仍然失败的案例的布局特征

---

## 🔄 实施调整（Deferred Items）

**调整日期**: 2025-11-13

### 延后到 v0.1.8 的任务

**任务**: 添加 `document_field_labels` 配置

**原因**：
- 当前修复（配置清理 + 跨字段排除 + 标签匹配修复）已经完成核心 Bug
- 需要先跑完整测试，验证当前修复的实际效果
- 根据测试结果，决定 `document_field_labels` 的具体内容（哪些文档字段真正需要排除）
- 遵循 Linus 的"分步优化"原则：Theory and practice sometimes clash. Theory loses.

**预期影响**：
- v0.1.7 预期收益：+3-5%（配置清理 + 跨字段排除 + 标签匹配修复）
- v0.1.8 预期收益：+2%（document_field_labels，如果测试证明需要）

**下一步**：
- v0.1.7 完整测试后，在实测报告中分析：
  - 是否还有"工程名称包含项目管理单位"的案例？
  - 有多少案例可以通过 document_field_labels 修复？
  - 具体需要排除哪些文档字段标签？
- 根据实测结果，在 v0.1.8 中实施或调整方案

**设计原则**：
- ✅ `label_alias.json` = 提取字段的标签（保持纯净）
- ✅ `document_field_labels` = 文档字段的标签（用于排除，应放在 `domain.json` 中）
- ✅ 语义清晰，职责分离（符合 Linus 的"好品味"原则）

---

## ✅ 验证标准

修复后，必须满足以下标准才能视为成功：

1. **自动通过率提升**：≥ +3%（32.0% → 35.0%+）
2. **FIELD_SIM_LOW_SUPPLIER 案例减少**：≥ 30%（21 → 14 以下）
3. **无回归**：
   - Exact 不降低
   - EXTRACT_EMPTY_* 警告不显著增加（< 5%）
4. **代码质量**：
   - TypeScript 类型安全
   - 代码可读性和可维护性

---

## 📚 相关文档

- **问题诊断**：`analysis/current/提取逻辑根本缺陷诊断报告.md`
- **项目状态**：`docs/PROJECT_STATUS.md`
- **实施记录**：`docs/implementation_record.md`（实测后更新）
- **提取器源码**：`packages/ocr-match-core/src/extract/extractor.ts`
- **配置文件**：`configs/v0.labs/10dae06c/label_alias.json`

---

## 🏁 总结

v0.1.7 是一个**P0 级修复版本**，解决了提取逻辑的根本性设计缺陷，回归原始需求："只提取供应商和工程名称两个字段"。

**核心价值**：
- ✅ 修复配置污染（混入了联系人、编号等字段）
- ✅ 修复标签匹配误判（子串匹配 → 精确匹配）
- ✅ 实施跨字段排除（避免盲目拼接其他字段）
- ✅ 移除续行拼接误判（endsWithEntity）

**预期收益**：+3-5% 自动通过率（6-10倍 ROI）

**下一步**：v0.1.8 将根据 v0.1.7 实测结果，决定是否需要 document_field_labels 配置。
