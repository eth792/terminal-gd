# 提取逻辑根本缺陷诊断报告

**创建日期**: 2025-11-13
**问题级别**: **P0 - 严重设计缺陷**
**影响范围**: 50% 失败案例（21/126 FIELD_SIM_LOW_SUPPLIER 案例）
**预期收益**: +5-7% 自动通过率（修复后 32.0% → 37-39%）

---

## 🔥 核心问题陈述

**用户原始需求**：从 OCR txt 中提取时，**必须且只能提取"供应商"和"工程名称"两个字段**，其他字段标签或信息都是噪点信息需要排查。

**当前实现偏差**：提取器会错误地提取其他字段（如"项目管理单位"、"订货通知单"、"供应商联系人"等）的内容，导致字段提取严重错误。

---

## 📋 典型失败案例分析

### 案例1：提取到工程名称片段

**文件**: `beijingsifangjibaogongchengjishuyouxiangongsi4100862381.txt`

**OCR 原文**（关键行）：
```
行3：报装编号：                    20230618                  供应商：
行4：                                                            北京四方继保工程技术有限公司
行5：项目管理单位：                客户服务中心市场及大客户服务室                            武汉恒安投资有限公司山海关五期
行6：                                        工程名称：
行7：                                                            A区"新建住宅供电配套工程
```

**实际提取结果**：
- `q_supplier` = `"A区新建住宅供电配套工程"` ❌（提取到了工程名称！）
- `q_project` = `"武汉恒安投资有限公司山海关五期A区新建住宅供电配套工程"`

**问题诊断**：
- 提取器应该在行3找到 `供应商：` 标签，向下拼接行4的供应商名称
- 但实际提取到了行7的工程名称内容
- **根本原因**：提取器在向上/向下查找时，没有检测到 `"工程名称："` 是另一个字段的标签，盲目拼接了其他字段的内容

---

### 案例2：提取到多个字段的混合

**文件**: `beijingsifangjibaogongchengjishuyouxiangongsi4100862689.txt`

**OCR 原文**（关键行）：
```
行3：报装编号：                      20210604                                                北京四方继保工程技术有限公司
行4：                                              供应商：
行5：                                                                    武汉绿地滨江置业有限公司"绿地国
行6：项目管理单位：                  客户服务中心市场及大客户服务室    工程名称：                  际金融城A02地块二期"新建住宅工
```

**实际提取结果**：
- `q_supplier` = `"项目管理单位:客户服务中心市场及大客户服务室工程名称:际金融城A02地块二期新建住宅工"` ❌
- 提取到了"项目管理单位"和"工程名称"两个字段的标签+内容！

**问题诊断**：
- 提取器在行4找到 `供应商：` 标签，但标签后值为空
- 触发向下查找（续行拼接）
- **应该向上查找到行3的供应商名称**，但实际却向下拼接了行6的内容
- 行6包含 `"项目管理单位："` 和 `"工程名称："` 两个明显的字段标签
- **根本原因**：续行拼接逻辑只检查当前字段的标签（`supplier`），没有检查其他字段的标签（`project`、`order` 等），导致盲目拼接

---

### 案例3：提取到标签本身

**文件**: `changjiangdianqi4100904488.txt`

**OCR 原文**（关键行）：
```
行4：报装编号：                    2022062302                供应商：                    长江电气集团股份有限公司
行5：项目管理单位：                                                                                武汉清龙鑫荣置业有限公司"新荣
行6：                    客户服务中心市场及大客户服务室    工程名称：                    TOD天街综合体项目"B地块新建住宅
行7：                                                              工程
```

**实际提取结果**：
- `q_supplier` = `"工程"` ❌（只提取到了 anchor 词！）

**问题诊断**：
- 提取器应该在行4找到 `供应商：` 标签，提取 `长江电气集团股份有限公司`
- 但实际提取到了 `"工程"` 这个单词
- **可能的原因**：
  1. 提取器误匹配到了其他标签（如 `"供应商联系人"`）
  2. 或者，提取器提取了行6-7的内容，经过某种截断逻辑后只剩下 `"工程"`
- **根本原因**：`label_alias.json` 中定义了不应该提取的标签（如 `"供应商联系人"`），导致误匹配

---

### 案例4：续行拼接失控

**文件**: `dahuazhinengkeji4100962394.txt`

**OCR 原文**（关键行）：
```
行3：报装编号：                  20110811-B                供应商：
行4：                                                                  大华智能科技有限公司
行5：                                                                武汉市武昌区团结名居H5竹园
行6：项目管理单位：                  运维检修部                工程名称：                  （20110811）新住配完善工程
```

**实际提取结果**：
- `q_supplier` = `"项目管理单位:运维检修部工程名称:(20110811)新住配完善工程"` ❌

**问题诊断**：
- 提取器在行3找到 `供应商：` 标签，标签后值为空
- 正确向下拼接行4的 `大华智能科技有限公司` ✅
- **但是！继续向下拼接了行5和行6的内容** ❌
- 行6包含 `"项目管理单位："` 和 `"工程名称："` 两个字段标签
- **根本原因**：续行拼接逻辑（`extractor.ts:123-142`）的 `hasOtherLabel` 检查只检查当前字段的标签，无法识别行6是其他字段的内容

---

## 🔍 三大根本性设计缺陷

### 缺陷1：配置污染（Label Alias Pollution）

**问题描述**：`label_alias.json` 中定义了不应该被提取的标签。

**当前配置**：
```json
{
  "supplier": [
    "供应商",           // ✅ 正确
    "供应单位名称",     // ✅ 正确
    "供应商联系人",     // ❌ 这是联系人字段，不是供应商名称！
    "供应商联系方式",   // ❌ 这是联系方式字段，不是供应商名称！
    "采购订单供应商"    // ✅ 可能正确
  ],
  "project": [
    "工程名称",         // ✅ 正确
    "T.程名称",         // ✅ 正确（OCR 错误）
    "单体工程名称",     // ✅ 正确
    "项目定义号",       // ❌ 这是编号字段，不是工程名称！
    "项目定义号.1",     // ❌ 这是编号字段，不是工程名称！
    "项目属性"          // ❌ 这是属性字段，不是工程名称！
  ],
  "order": [...]        // ❌ 整个 order 字段都不应该存在！
}
```

**影响**：
- `"供应商联系人"` 会误匹配到 OCR 原文中的 `"供应商联系人/电话："` 行
- 导致提取器在错误的位置开始提取，拼接到错误的内容

**原始需求违背**：
- 用户明确要求**只提取"供应商"和"工程名称"两个字段**
- 但当前配置混入了其他字段的标签（如"供应商联系人"、"项目定义号"等）
- `order` 字段完全不应该存在

---

### 缺陷2：缺少跨字段标签排除（No Cross-Field Label Exclusion）

**问题描述**：`extractField` 函数在检查 `hasOtherLabel` 时，**只检查当前字段的标签**，没有检查其他字段的标签。

**当前代码**（`extractor.ts:133`）：
```typescript
const hasOtherLabel = labels.some(l => nextLine.includes(l));  // ⚠️ labels 只包含当前字段的标签！
```

**问题**：
- 在提取 `supplier` 时，`labels` 只包含 `["供应商", "供应单位名称", ...]`
- 当下一行包含 `"工程名称："` 时，`hasOtherLabel` 为 `false`（因为 `"工程名称"` 不在 `supplier` 的标签列表中）
- 提取器盲目地拼接了其他字段的内容

**预期行为**：
- 在提取 `supplier` 时，应该检查下一行是否包含**任何字段的标签**（包括 `project`、`order` 等）
- 如果下一行包含其他字段的标签，应该立即停止拼接

---

### 缺陷3：缺少文档字段标签黑名单（No Document Field Label Blacklist）

**问题描述**：没有定义"文档字段标签"列表（如 `"订货通知单"`、`"项目管理单位"`、`"验收情况"` 等）。

**常见的文档字段标签**（应该被视为噪点）：
- `"订货通知单号"`
- `"订货通知单"`
- `"到货验收单号"`
- `"项目管理单位"`
- `"验收情况"`
- `"交货地点"`
- `"收货联系人"`
- `"备注"`
- `"说明"`

**当前处理**：
- `domain.json` 中的 `noise_words` 只包含部分文档字段（如 `"订货通知单号"`、`"订单号"` 等）
- 但 `noise_words` 只用于**截断**（`truncateByNoiseWords`），不用于**排除**（停止拼接）
- 导致提取器会拼接包含这些标签的行，虽然最后会被截断，但仍然会引入不必要的内容

**预期行为**：
- 应该定义一个"文档字段标签黑名单"
- 在向上/向下查找时，如果遇到黑名单中的标签，应该立即停止拼接
- 这些标签应该优先于 `hasOtherLabel` 检查，作为强制停止条件

---

## 💡 修复方案

### 方案1：清理 `label_alias.json` 配置（P0 优先级）

**目标**：移除所有不应该提取的标签，严格遵循"只提取供应商和工程名称"的原始需求。

**具体操作**：

1. **清理 `supplier` 字段**：
   ```json
   {
     "supplier": [
       "供应商",
       "供应单位名称",
       "采购订单供应商"
     ]
   }
   ```
   - ❌ 移除：`"供应商联系人"`, `"供应商联系方式"`（这些是联系信息字段，不是供应商名称）

2. **清理 `project` 字段**：
   ```json
   {
     "project": [
       "工程名称",
       "T.程名称",
       "单体工程名称"
     ]
   }
   ```
   - ❌ 移除：`"项目定义号"`, `"项目定义号.1"`, `"项目属性"`（这些是编号/属性字段，不是工程名称）

3. **移除 `order` 字段**：
   - ❌ 完全删除 `order` 字段及其所有标签
   - 原始需求中没有提到需要提取订单信息

**预期收益**：
- 避免误匹配到错误的标签位置
- 减少配置复杂度
- 严格遵循原始需求

---

### 方案2：添加跨字段标签排除机制（P0 优先级）

**目标**：在提取某个字段时，检查其他字段的标签作为排除条件。

**实施步骤**：

1. **修改 `extractField` 函数签名**：
   ```typescript
   function extractField(
     lines: string[],
     linesRaw: string[],
     labels: string[],           // 当前字段的标签
     allFieldLabels: string[],   // 🆕 所有字段的标签（包括其他字段）
     noiseWords: string[]
   ): string
   ```

2. **在 `extract` 函数中收集所有标签**：
   ```typescript
   export function extract(text: string, config: ExtractConfig): ExtractResult {
     // 收集所有字段的标签
     const allFieldLabels = [
       ...config.label_alias.supplier,
       ...config.label_alias.project,
       // 如果有 order 字段，也加入（但应该先删除）
     ];

     // 提取供应商（传入所有标签）
     const supplier = extractField(
       lines,
       linesRaw,
       config.label_alias.supplier,
       allFieldLabels,  // 🆕 传入所有标签
       config.domain.noise_words
     );

     // 提取工程名称（传入所有标签）
     const project = extractField(
       lines,
       linesRaw,
       config.label_alias.project,
       allFieldLabels,  // 🆕 传入所有标签
       config.domain.noise_words
     );
   }
   ```

3. **修改 `hasOtherLabel` 检查逻辑**：
   ```typescript
   // 当前逻辑（错误）
   const hasOtherLabel = labels.some(l => nextLine.includes(l));

   // 修复后逻辑
   const hasOtherLabel = allFieldLabels
     .filter(l => !labels.includes(l))  // 排除当前字段的标签
     .some(l => nextLine.includes(l));  // 检查是否包含其他字段的标签
   ```

4. **应用到所有向上/向下查找逻辑**：
   - 向上查找（`extractor.ts:93-120`）
   - 续行拼接（`extractor.ts:123-142`）

**预期收益**：
- 避免盲目拼接其他字段的内容
- 提高提取精度
- 救回 11-16 个 FIELD_SIM_LOW_SUPPLIER 案例

---

### 方案3：添加文档字段标签黑名单（P1 优先级）

**目标**：定义"文档字段标签"列表，作为强制停止拼接的条件。

**实施步骤**：

1. **在 `domain.json` 中添加黑名单**：
   ```json
   {
     "document_field_labels": [
       "订货通知单",
       "订货通知单号",
       "到货验收单",
       "到货验收单号",
       "项目管理单位",
       "验收情况",
       "交货地点",
       "收货地点",
       "收货联系人",
       "承运商联系人",
       "备注",
       "说明",
       "报装编号",
       "支付方式",
       "开户行",
       "纳税人识别号",
       "开票信息",
       "账号",
       "税号"
     ]
   }
   ```

2. **在 `extractField` 中添加黑名单检查**：
   ```typescript
   // 向上查找前检查
   if (needLookupPrev && i > 0) {
     const prevLine = linesRaw[i - 1].trim();

     // 🆕 检查是否包含文档字段标签（黑名单）
     const hasDocumentLabel = config.domain.document_field_labels?.some(
       label => prevLine.includes(label)
     );
     if (hasDocumentLabel) {
       // 不向上查找，使用当前行的值
     } else {
       // 正常向上查找逻辑
     }
   }

   // 续行拼接前检查
   if (i + 1 < lines.length) {
     const nextLine = linesRaw[i + 1].trim();

     // 🆕 检查是否包含文档字段标签（黑名单）
     const hasDocumentLabel = config.domain.document_field_labels?.some(
       label => nextLine.includes(label)
     );
     if (!hasDocumentLabel && isDeepIndent && !hasOtherLabel && ...) {
       // 正常拼接逻辑
     }
   }
   ```

**预期收益**：
- 进一步提高提取精度
- 避免拼接文档字段的内容
- 减少噪声干扰

---

## 📈 预期效果

**当前状态**（v0.1.6）：
- 自动通过率：32.0%
- FIELD_SIM_LOW_SUPPLIER 案例：21 个（13.9% 失败原因占比）
- 其中 f1_score = 0.0 的案例：11 个（50%）

**修复后预期**（v0.1.7-v0.1.8）：
- 自动通过率：**37-39%** (+5-7%)
- FIELD_SIM_LOW_SUPPLIER 案例：**5-10 个**（减少 50-75%）
- 救回案例数：**11-16 个**

**ROI 分析**：
- 修复成本：2-3 小时（配置清理 + 代码修改 + 测试）
- 收益：+5-7% 自动通过率
- **ROI：10倍** （相比 Rule 3.5 调整的 0.5% 收益）

---

## 🎯 实施优先级

### 第一阶段（v0.1.7）：配置清理 + 跨字段排除

**任务**：
1. ✅ 清理 `label_alias.json`（移除污染标签）
2. ✅ 添加跨字段标签排除机制（修改 `extractField` 函数）
3. ✅ 完整测试（222 样本）

**预期成果**：
- 自动通过率：32.0% → **35-37%** (+3-5%)

---

### 第二阶段（v0.1.8）：文档字段黑名单

**任务**：
1. ✅ 在 `domain.json` 中添加 `document_field_labels`
2. ✅ 在 `extractField` 中添加黑名单检查
3. ✅ 完整测试（222 样本）

**预期成果**：
- 自动通过率：35-37% → **37-39%** (+2%)

---

## 🚨 关键风险

1. **过度严格的排除可能导致漏提取**：
   - 如果跨字段排除逻辑过于激进，可能会导致正确的内容被错误排除
   - 缓解措施：在测试中监控 `EXTRACT_EMPTY_*` 警告的增加

2. **OCR 错误可能影响标签匹配**：
   - 如果 OCR 将 `"供应商"` 错误识别为 `"供应商"` 等，可能导致标签匹配失败
   - 缓解措施：在 `label_alias.json` 中保留常见 OCR 错误变体（如 `"T.程名称"`）

3. **布局复杂性可能超出预期**：
   - 部分文档的布局可能非常复杂，单纯的向上/向下查找可能无法正确提取
   - 缓解措施：在完整测试后，分析仍然失败的案例，考虑引入更复杂的布局解析逻辑（如表格识别）

---

## ✅ 验证标准

修复后，必须满足以下标准才能视为成功：

1. **自动通过率提升**：≥ +5%（32.0% → 37.0%+）
2. **FIELD_SIM_LOW_SUPPLIER 案例减少**：≥ 50%（21 → 10 以下）
3. **无回归**：
   - Exact 不降低
   - EXTRACT_EMPTY_* 警告不显著增加（< 5%）
4. **代码质量**：
   - TypeScript 类型安全
   - 单元测试覆盖核心逻辑
   - 代码可读性和可维护性

---

## 📚 相关文档

- **当前版本分析**：`analysis/v0.1.6/v0.1.6_实测报告.md`
- **项目状态**：`docs/PROJECT_STATUS.md`
- **实施记录**：`docs/implementation_record.md`
- **提取器源码**：`packages/ocr-match-core/src/extract/extractor.ts`
- **配置文件**：`configs/v0.labs/10dae06c/label_alias.json`

---

## 🏁 总结

这是一个**严重的设计偏差问题**，违背了"只提取供应商和工程名称两个字段"的原始需求。修复后预期带来 **+5-7% 自动通过率提升**，是当前最高 ROI 的优化方向（10倍于 Rule 3.5 调整）。

修复方案清晰、风险可控、验证标准明确，应立即进入实施阶段。
