# v0.1.9 Dynamic Threshold Optimization - 失败分析

**执行日期**: 2025-11-19
**运行ID**: `run_20251119_11_32`
**状态**: ❌ **失败，已回滚**

---

## 执行总结

**目标**: 实施动态阈值优化，提升自动通过率从 32% 到 35-37%

**实际结果**: 灾难性回归
- 自动通过率: 32.0% → **3.6%** (-28.4pp, -88.7%)
- Exact matches: 71 → **8** (-63, -88.7%)
- Review: 17 → **87** (+70, +412%)
- **已立即回滚**

---

## 对比数据

| 指标 | Baseline (v0.1.8) | New (v0.1.9) | 变化 |
|------|-------------------|--------------|------|
| **Exact** | 71 (32.0%) | 8 (3.6%) | **-63 (-88.7%)** ❌ |
| **Review** | 17 (7.7%) | 87 (39.2%) | +70 (+412%) |
| **Fail** | 134 (60.4%) | 127 (57.2%) | -7 (-5.2%) |
| **自动通过率** | 32.0% | 3.6% | **-28.4pp** ❌❌❌ |

**Failure Reasons变化**:
- **DELTA_TOO_SMALL**: 17 → **87** (+70, +412%) ← 根本原因
- **FIELD_SIM_LOW_PROJECT**: 67 → 60 (-7, -10.4%)
- **SUPPLIER_HARD_REJECT**: 29 → 29 (0)
- **EXTRACT_EMPTY_PROJECT**: 18 → 18 (0)

**性能影响**:
- 总耗时: 3.2min → 5.7min (+78%)
- 平均耗时: 860ms/file → 1.5s/file (+74%)

---

## 根本原因分析

### 设计错误：误判Rule 5为"坏品味"

**错误假设**:
> "Rule 5（高置信度旁路）是特殊情况，应该用连续函数消除"

**真相**:
Rule 5 **不是设计缺陷**，而是**必要的保护机制**：

```typescript
// Rule 5 的实际作用（v0.1.5引入）
if (top1.score >= 0.85 && top1.f1_score >= 0.80 && top1.f2_score >= 0.75) {
  return { bucket: 'exact', reason: null };  // 绕过delta检查
}
```

**它解决的问题**：
- 当两个候选非常相似时（如"武汉XX项目一期" vs "武汉XX项目二期"）
- Delta可能很小（< 0.03），触发DELTA_TOO_SMALL
- 但如果top1的分数本身就极高（score >= 0.85, f1 >= 0.80, f2 >= 0.75）
- 那么top1就是正确答案，不应该因为delta小而降级为review

**删除Rule 5的后果**：
- 63个高分case（原本通过Rule 5直接判定为exact）
- 现在必须通过Rule 7的delta检查
- 但它们的delta < 0.03，被降级为review
- 导致自动通过率从32%暴跌到3.6%

---

## 技术洞察

### Linus视角的重新审视

**我的错误**：
> "Rule 5是if判断特殊情况，应该用连续函数消除"

**Linus会说什么**：
> "你根本没理解Rule 5的**数据结构意义**。这不是特殊情况，这是**多级决策链**的一部分。"

**正确理解**：

分桶决策是**多级过滤器**，不是单一函数：
```
Rule 1-4: 低质量过滤（提取失败、无候选、字段过低）
  ↓
Rule 5:   高质量快速通道（绕过delta检查）  ← 这不是bug！
  ↓
Rule 6:   Delta检查（防止相似候选混淆）
  ↓
Rule 7:   标准通过检查（加权分数 + delta）
```

**类比**：
- Rule 5 = 高速公路ETC通道（VIP直达）
- Rule 7 = 人工收费通道（需要排队验证）
- 删除Rule 5 = 强制所有车辆走人工通道 → 拥堵（review激增）

---

## 动态阈值的真正问题

**原始设计目标**：
解决 `changjiangdianqi` 案例（f1=1.0, f2=0.597）因标点差异fail的问题

**动态阈值公式**：
```typescript
threshold = 0.6 - max(0, (max(f1, f2) - 0.8)) * 0.5
```

**实际效果**：
- **FIELD_SIM_LOW_PROJECT**: 67 → 60 (-7) ← 有效果，但不够
- 但代价是删除Rule 5导致exact暴跌63个

**为什么动态阈值不够**？

Case `changjiangdianqi`:
- f1=1.0, f2=0.597
- 动态阈值: `0.6 - (1.0 - 0.8) * 0.5 = 0.5`
- f2=0.597 > 0.5 ✅ 通过Rule 3
- **但是**：可能卡在Rule 7的加权分数检查（autoPass=0.75）

**真正的瓶颈**：
不是固定阈值，而是**Rule 7的加权分数要求过高**！

---

## 关键教训

### 1. 深度理解 > 表面模式匹配

❌ **错误思维**：
"看到if判断 → 特殊情况 → 应该消除"

✅ **正确思维**：
"为什么需要这个if？它在数据流中的作用是什么？"

### 2. 数据驱动分析

**应该做的**（但没做）：
1. 分析那63个exact case的共同特征：
   - 它们的delta分布如何？
   - 为什么它们需要Rule 5？
2. 分析`FIELD_SIM_LOW_PROJECT`的67个case：
   - 动态阈值能救回多少？
   - 真正的瓶颈在哪里？

**实际做的**（错误）：
"感觉Rule 5是特殊情况，删掉试试"

### 3. Linus式"Good Taste"的真正含义

**我理解的**：
"消除所有if判断特殊情况"

**Linus真正的意思**：
"简化数据结构，让特殊情况**自然消失**，而不是**强行删除**"

**链表删除的启示**：
- Linus优化的是**数据结构**（用dummy head消除边界）
- 不是简单地删除边界检查（那会crash！）

---

## 正确的优化路径

### Step 1: 分析FIELD_SIM_LOW_PROJECT的67个case

**问题**：
为什么 f2_score < 0.6？

**可能原因**：
1. OCR标点误差（如`changjiangdianqi`）
2. 项目名称长度不匹配（"XX项目" vs "XX项目一期"）
3. DB中项目名称格式不一致

**解决方案**：
- 标点归一化（已有，但可能不够）
- **子串加权**（v0.2.0计划）← 这才是正确方向
- DB数据清洗

### Step 2: 分析Rule 5的63个case

**问题**：
为什么它们的delta < 0.03？

**可能原因**：
- DB中存在多个非常相似的项目（"一期" vs "二期"）
- 这些case的确需要旁路

**解决方案**：
- **保留Rule 5**
- 或者：降低minDeltaTop阈值（0.03 → 0.01）？
  - 但这可能误放低质量匹配

---

## 回滚决策

**触发条件**（tasks.md定义）：
- Exact matches < 71 ✅（实际8，远低于71）
- 总耗时 > 10min ❌（5.7min，但仍比baseline慢78%）
- 新failure reason ❌（DELTA_TOO_SMALL不是新的，但数量激增）

**回滚操作**：
```bash
git checkout packages/ocr-match-core/src/bucket/bucketize.ts
pnpm -F ./packages/ocr-match-core build
```

**回滚验证**：
- ✅ 构建成功
- ✅ 代码恢复到v0.1.8状态

---

## 下一步建议

### 短期（修复v0.1.9）

**Option 1: 保守方案**
- 保留Rule 5，不删除
- 只实施动态阈值（Tasks 1.1-1.4, 1.6-1.7）
- 跳过Task 1.5

**Option 2: 激进方案**
- 降低minDeltaTop: 0.03 → 0.01
- 删除Rule 5，但用更宽松的delta阈值补偿
- **风险高**：可能误放低质量匹配

**Option 3: 数据驱动方案**（推荐）
1. 导出那63个通过Rule 5的case
2. 分析它们的delta分布
3. 基于数据决定：
   - 是否调整delta阈值？
   - 还是Rule 5确实必要？

### 中期（v0.2.0）

**优先级调整**：
1. ~~动态阈值~~ → **子串加权**（更直接解决FIELD_SIM_LOW_PROJECT）
2. 可观测性增强（中间输出，方便调试）

**子串加权方案**：
```typescript
// rank.ts
baseScore = computeJaccard(q, cand);
substringBonus = isSubstring(q, cand) ? 0.15 : 0;
finalScore = min(1.0, baseScore + substringBonus);
```

这会直接解决：
- "XX项目" vs "XX项目一期" → substring bonus +0.15
- FIELD_SIM_LOW_PROJECT预计减少30-40例

---

## 总结

**失败原因**：
- 设计错误：误判Rule 5为"坏品味特殊情况"
- 未做数据分析：不了解Rule 5保护的63个case的特征
- 盲目应用Linus原则：表面模仿而非深度理解

**关键洞察**：
- Rule 5不是bug，是feature
- 分桶逻辑是多级过滤器，不是单一函数
- 优化应该基于数据，而非感觉

**下次改进**：
1. 先分析数据，再设计方案
2. 深度理解现有逻辑的存在理由
3. 小步迭代：先保守测试，再激进优化
4. Sample test不够，必须Full test验证

---

**记录时间**: 2025-11-19 11:42
**回滚状态**: ✅ 已完成
**Spec状态**: ❌ 失败，需重新设计
